#!/usr/bin/python
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
# Author: "Chris Ward <cward@redhat.com>

'''
CLI for deploying metrique
'''

import datetime
from functools import partial
import getpass
import glob
import importlib
import multiprocessing
import os
import random
import re
import signal
import shlex
import shutil
import socket
import string
import subprocess
import sys
import virtualenv

pjoin = os.path.join
env = os.environ

virtenv_activated = False
logger = virtualenv.Logger([(0, sys.stdout)])
call_subprocess = virtualenv.call_subprocess

__pkgs__ = ['metrique', 'metriqued', 'metriquec', 'metriqueu',
            'metriquet', 'plotrique']
__actions__ = ['build', 'sdist', 'install', 'develop', 'register',
               'bump', 'status']
__bumps__ = ['x', 'y', 'z', 'r']
RE_VERSION_X = re.compile(r"__version__\s+=\s+[\"']((\d+).\d+.\d+)[\"']")
RE_VERSION_Y = re.compile(r"__version__\s+=\s+[\"'](\d+.(\d+).\d+)[\"']")
RE_VERSION_Z = re.compile(r"__version__\s+=\s+[\"'](\d+.\d+.(\d+))[\"']")
RE_RELEASE = re.compile(r"__release__ = [\"']?((\d+)a?)[\"']?")

RPM_SYSTEM_RELEASE = "/etc/system-release"
RPMS = ['git', 'python', 'python-devel', 'python-setuptools', 'python-pip',
        'supervisor', 'vim', 'screen', 'psmisc', 'net-tools', 'rng-tools',
        'mlocate', 'tar', 'pigz', 'rsync', 'chrony',
        'gcc', 'gcc-c++', 'gcc-gfortran', 'freetype-devel', 'libpng-devel',
        'mongodb', 'mongodb-server', 'nginx', 'krb5-devel', 'postgresql',
        'postgresql-devel']


def deactivate(virtenv):
    sys.path = [p for p in sys.path if not p.startswith(virtenv)]


def activate(args=None):
    global virtenv_activated

    if virtenv_activated:
        return
    elif (hasattr(args, 'virtenv') and args.virtenv):
        virtenv = args.virtenv
    else:
        virtenv = env.get('VIRTUAL_ENV', '')

    if virtenv:
        activate_this = pjoin(virtenv, 'bin', 'activate_this.py')
        if os.path.exists(activate_this):
            execfile(activate_this, dict(__file__=activate_this))
            env['VIRTUAL_ENV'] = virtenv
            virtenv_activated = True
            logger.info('Virtual Env (%s): Activated' % virtenv)
    return virtenv


def rand_chars(size=6, chars=string.ascii_uppercase + string.digits):
    # see: http://stackoverflow.com/questions/2257441
    return ''.join(random.choice(chars) for x in range(size))


USER = getpass.getuser()
VIRTUAL_ENV = env.get('VIRTUAL_ENV', '')
NOW = datetime.datetime.utcnow().strftime('%FT%H%M%S')

HOSTNAME = socket.gethostname()
try:
    # try to get one of the local inet device ip addresses
    LOCAL_IP = socket.gethostbyname(HOSTNAME)
except Exception:
    LOCAL_IP = '127.0.0.1'

PASSWORD = rand_chars(10)
COOKIE_SECRET = rand_chars(50)

HERE = os.getcwd()
GIT_DIR = env.get('METRIQUE_GIT', HERE)
SRC_DIR = pjoin(GIT_DIR, 'src/')

HOME_DIR = env.get('METRIQUE_HOME', os.path.expanduser('~/'))
USER_DIR = env.get('METRIQUE_USR', pjoin(HOME_DIR, '.metrique'))

logger.warn('-'*30)
logger.warn('Started at  : %s' % NOW)
logger.warn('Current User: %s' % USER)
logger.warn('Current CWD : %s' % HERE)
logger.warn('Virtual Env : %s' % VIRTUAL_ENV)
logger.warn('Hostname    : %s' % HOSTNAME)
logger.warn('Local IP    : %s' % LOCAL_IP)
logger.warn('GIT Repo    : %s' % GIT_DIR)
logger.warn('Source Path : %s' % SRC_DIR)
logger.warn('This file   : %s' % __file__)
logger.warn('Home Path   : %s' % HOME_DIR)
logger.warn('User Path   : %s' % USER_DIR)
logger.warn('-'*30)

if not (os.path.exists(SRC_DIR) or
        os.path.exists(pjoin(SRC_DIR, '.git'))):
    raise OSError("can't find metrique src/ path; `export METRIQUE_GIT=...`?")

# set cache dir so pip doesn't have to keep downloading over and over
PIP_DIR = pjoin(USER_DIR, '.pip')
PIP_CACHE_DIR = pjoin(PIP_DIR, 'download-cache')
PIP_ACCEL_DIR = pjoin(USER_DIR, '.pip-accel')
PIP_EGGS = pjoin(USER_DIR, '.python-eggs')
env['PIP_DOWNLOAD_CACHE'] = env.get('PIP_DOWNLOAD_CACHE', PIP_CACHE_DIR)
env['PIP_ACCEL_CACHE'] = env.get('PIP_ACCEL_CACHE', PIP_ACCEL_DIR)
env['PYTHON_EGG_CACHE'] = env.get('PYTHON_EGG_CACHE', PIP_EGGS)

TRASH_DIR = env.get('METRIQUE_TRASH', pjoin(USER_DIR, 'trash'))
LOG_DIR = env.get('METRIQUE_LOG', pjoin(USER_DIR, 'logs'))
ETC_DIR = env.get('METRIQUE_ETC', pjoin(USER_DIR, 'etc'))
PID_DIR = env.get('METRIQUE_PID', pjoin(USER_DIR, 'pids'))
BACKUP_DIR = env.get('METRIQUE_BACKUP', pjoin(USER_DIR, 'backup'))
TEMP_DIR = env.get('METRIQUE_TEMP', pjoin(USER_DIR, 'tmp'))
CACHE_DIR = env.get('METRIQUE_CACHE', pjoin(USER_DIR, 'cache'))
MONGODB_DIR = env.get('METRIQUE_MONGODB', pjoin(USER_DIR, 'mongodb'))
CELERY_DIR = env.get('METRIQUE_CELERY', pjoin(USER_DIR, 'celery'))
GNUPG_DIR = env.get('METRIQUE_GNUPG', pjoin(USER_DIR, 'gnupg'))

METRIQUED_JSON = pjoin(ETC_DIR, 'metriqued.json')
METRIQUE_JSON = pjoin(ETC_DIR, 'metrique.json')

STATIC_PATH = env.get('METRIQUE_STATIC', pjoin(SRC_DIR, 'metriqued/metriqued/static/'))
API_DOCS_PATH = env.get('METRIQUE_API_DOCS', pjoin(GIT_DIR, 'docs/build/html/'))

SYS_FIRSTBOOT_PATH = pjoin(USER_DIR, '.firstboot_sys')
METRIQUED_FIRSTBOOT_PATH = pjoin(USER_DIR, '.firstboot_metriqued')

SSL_CERT = pjoin(ETC_DIR, 'metrique.crt')
SSL_KEY = pjoin(ETC_DIR, 'metrique.key')
SSL_PEM = pjoin(ETC_DIR, 'metrique.pem')

MONGODB_FIRSTBOOT_PATH = pjoin(USER_DIR, '.firstboot_mongodb')
MONGODB_CONF = pjoin(ETC_DIR, 'mongodb.conf')
MONGODB_PIDFILE = pjoin(PID_DIR, 'mongodb.pid')
MONGODB_LOCKFILE = pjoin(MONGODB_DIR, 'mongod.lock')
MONGODB_LOG = pjoin(LOG_DIR, 'mongodb.log')
MONGODB_JSON = pjoin(ETC_DIR, 'mongodb.json')
MONGODB_JS = pjoin(ETC_DIR, 'mongodb.js')
MONGODB_KEYFILE = pjoin(ETC_DIR, 'mongodb.key')

CELERY_JSON = pjoin(ETC_DIR, 'celery.json')
CELERYD_PIDFILE = pjoin(PID_DIR, 'celeryd.pid')
CELERYBEAT_PIDFILE = pjoin(PID_DIR, 'celerybeat.pid')
CELERY_LOGFILE = pjoin(LOG_DIR, 'celeryd.log')

NGINX_CONF = pjoin(ETC_DIR, 'nginx.conf')
NGINX_ACCESS_LOG = pjoin(LOG_DIR, 'nginx_access.log')
NGINX_ERROR_LOG = pjoin(LOG_DIR, 'nginx_error.log')
NGINX_PIDFILE = pjoin(PID_DIR, 'nginx.pid')

SUPERVISORD_CONF = pjoin(ETC_DIR, 'supervisord.conf')
SUPERVISORD_PIDFILE = pjoin(PID_DIR, 'supervisord.pid')
SUPERVISORD_LOGFILE = pjoin(LOG_DIR, 'supervisord.log')
SUPERVISORD_HISTORYFILE = pjoin(TEMP_DIR, 'supervisord_history')


def get_pid(pidfile):
    try:
        return int(''.join(open(pidfile).readlines()).strip())
    except IOError:
        return 0


def makedirs(path, mode=0700):
    if not path.startswith('/'):
        raise OSError("requires absolute path! got %s" % path)
    if not os.path.exists(path):
        os.makedirs(path, mode)
    return path


def remove(path, quiet=True):
    if isinstance(path, (list, tuple)):
        [remove(p) for p in path]
    else:
        assert isinstance(path, basestring)
        if os.path.exists(path):
            if os.path.isdir(path):
                shutil.rmtree(path)
            else:
                os.remove(path)
        elif not quiet:
            logger.warn('[remove] %s not found' % path)


def system(cmd, fork=False, sig=None, sig_func=None):
    if sig and sig_func:
        signal.signal(sig, sig_func)

    logger.debug("Running: %s" % cmd)
    cmd = cmd.split()
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    text = p.stdout.read()
    return text


def run(cmd, cwd, show_stdout):
    cwd = cwd or SRC_DIR
    logger.info("[%s] Running ...\n`%s`" % (cwd, ' '.join(cmd)))
    try:
        call_subprocess(cmd, cwd=cwd, show_stdout=show_stdout)
    except KeyboardInterrupt:
        logger.warn('CTRL-C killed')
        sys.exit(1)
    except Exception as e:
        raise OSError('[%s] %s' % (e, ' '.join(cmd)))


def call(cmd, cwd=None, show_stdout=True, fork=False, pidfile=None,
         sig=None, sig_func=None):
    cmd = shlex.split(cmd.strip())
    if sig and sig_func:
        signal.signal(sig, sig_func)

    if fork:
        pid = os.fork()
        if pid == 0:
            run(cmd, cwd, show_stdout)
        elif pidfile:
            with open(pidfile, 'w') as f:
                f.write(str(pid))
    else:
        run(cmd, cwd, show_stdout)
    logger.info(" ... Done!")


def adjust_options(options, args):
    options.no_site_packages = True
virtualenv.adjust_options = adjust_options


def backup(saveas, path):
    gzip = system('which pigz') or system('which gzip')
    cmd = 'tar -c --use-compress-program=%s -f %s %s' % (gzip, saveas, path)
    system(cmd)


def backup_clean(args, path, prefix):
    keep = args.keep if args.keep != 0 else 3
    path = pjoin(path, prefix) + '*'
    files = sorted(glob.glob(path), reverse=True)
    to_remove = files[keep:]
    logger.debug('Removing %i backups' % len(to_remove))
    [remove(f) for f in to_remove]


def terminate(pidfile, sig=signal.SIGTERM):
    if os.path.exists(pidfile):
        pid = get_pid(pidfile)
        try:
            os.kill(pid, sig)
        except OSError:
            logger.warn("%s not found" % pid)
        else:
            logger.warn("%s killed" % pid)
        remove(pidfile)
    else:
        logger.warn("[terminate] %s does not exist" % pidfile)


def celeryd_terminate(sig=None, frame=None):
    terminate(CELERYD_PIDFILE)
    sys.exit(2)


def celeryd_loop(args):
    fork = not args.nofork
    x = 'worker'
    logfile = '--logfile=%s' % CELERY_LOGFILE
    loglvl = '-l INFO'
    pidfile = '--pidfile=%s' % CELERYD_PIDFILE
    app = '-A %s' % args.tasks_mod
    cmd = 'celery %s %s %s %s %s' % (x, logfile, loglvl, pidfile, app)
    call(cmd, fork=fork, sig=signal.SIGTERM, sig_func=celeryd_terminate)


def celeryd_task(args):
    tasks = importlib.import_module(args.tasks_mod)
    task = getattr(tasks, args.task)
    return task.run()


def celeryd(args):
    if args.command == "start":
        celeryd_loop(args)
    elif args.command == "stop":
        terminate(CELERYD_PIDFILE)
    elif args.command == "clean":
        remove(CELERYD_PIDFILE)
    else:
        raise ValueError("unknown command %s" % args.command)


def celerybeat_terminate(sig=None, frame=None):
    terminate(CELERYBEAT_PIDFILE)
    sys.exit(2)


def celerybeat_run(args):
    fork = not args.nofork
    x = 'beat'
    logfile = '--logfile=%s' % CELERY_LOGFILE
    loglvl = '-l INFO'
    pidfile = '--pidfile=%s' % CELERYBEAT_PIDFILE
    app = '-A %s' % args.tasks_mod
    cmd = 'celery %s %s %s %s %s' % (x, logfile, loglvl, pidfile, app)
    call(cmd, fork=fork, sig=signal.SIGTERM, sig_func=celerybeat_terminate)


def celerybeat(args):
    if args.command == "start":
        celerybeat_run(args)
    elif args.command == "stop":
        terminate(CELERYBEAT_PIDFILE)
    elif args.command == "clean":
        remove(CELERYBEAT_PIDFILE)
    else:
        raise ValueError("unknown command %s" % args.command)


def supervisord_terminate(sig=None, frame=None):
    terminate(SUPERVISORD_PIDFILE)
    sys.exit(2)


def supervisord_run(args):
    cmd = 'supervisord -c %s' % SUPERVISORD_CONF
    call(cmd, fork=True, sig=signal.SIGTERM, sig_func=supervisord_terminate)


def supervisord(args):
    if args.command == "start":
        supervisord_run(args)
    elif args.command == "stop":
        terminate(SUPERVISORD_PIDFILE)
    elif args.command == "clean":
        remove(SUPERVISORD_PIDFILE)
    else:
        raise ValueError("unknown command %s" % args.command)


def _metrique_user_register():
    from metrique import pyclient
    m = pyclient()
    m.user_register()


def _metriqued_firstboot(args):
    if os.path.exists(METRIQUED_FIRSTBOOT_PATH):
        return
    args.command = 'start'
    metriqued(args)
    _metrique_user_register()
    with open(METRIQUED_FIRSTBOOT_PATH, 'w') as f:
        f.write(NOW)
    args.command = 'stop'
    metriqued(args)


def _metriqued_stop(args):
    from metriqueu.utils import get_pids
    running = get_pids(PID_DIR)
    sig = args.signal or signal.SIGTERM
    for pid in running:
        logger.info("Sending signal (%s) to (%s)" % (sig, pid))
        os.kill(pid, sig)


def _metriqued_start(args):
    # A) there are no instances currently running
    # B) there are instances running; add additional
    from metriqued.tornadohttp import MetriqueHTTP
    from metriqueu.utils import get_pids

    config_file = args.server_config_file
    pids = []
    port = args.port
    fork = not args.nofork
    instances = args.instances or 0

    if instances > 1:
        # we want to start more than one instance, we must fork
        for k in range(instances):
            pid = os.fork()
            if pid == 0:
                running_k = len(get_pids(PID_DIR))
                port = port + running_k
                metriqued = MetriqueHTTP(config_file=config_file, port=port)
                metriqued.start()
                sys.exit()
            else:
                pids.append(pid)
            port += 1
    else:
        metriqued = MetriqueHTTP(config_file=config_file, port=port)
        metriqued.start(fork=fork)
    logger.info('Started: %s' % ', '.join(map(str, pids)))


def metriqued_backup(args):
    hosts_dir = '/etc/hosts'
    to_backup = [ETC_DIR, hosts_dir]

    for path in to_backup:
        prefix = 'metriqued.%s' % os.path.basename(path)
        saveas = '__'.join((prefix, HOSTNAME, NOW)) + '.tar.gz'
        saveas = pjoin(BACKUP_DIR, saveas)
        backup(saveas, path)
        backup_clean(args, BACKUP_DIR, prefix)
        if args.scp_export:
            user = args.scp_user
            host = args.scp_host
            out_dir = args.scp_out_dir
            cmd = 'scp %s %s@%s:%s' % (saveas, user, host, out_dir)
            call(cmd)


def metriqued(args):
    '''
    START, STOP, RESTART, RELOAD,
    '''
    # needed by metriqued_* commands
    from metriqueu.utils import get_pids

    cmd = args.command

    if not args.instances:
        args.instances = 1

    if cmd == 'start':
        _metriqued_start(args)
    elif cmd == 'stop':
        _metriqued_stop(args)
    elif cmd == 'status':
        logger.info('RUNNING: %s' % ', '.join(map(str, get_pids(PID_DIR))))
    elif args.command == 'firstboot':
        _metriqued_firstboot(args)
    else:
        raise SystemExit('bad command "%s"... Try --help' % cmd)


def nginx_terminate(sig=None, frame=None):
    terminate(NGINX_PIDFILE)
    sys.exit(2)


def nginx(args):
    fork = not args.nofork
    cmd = 'nginx -c %s' % NGINX_CONF
    if args.command == 'test':
        call('%s -t' % cmd)
    elif args.command == 'start':
        call(cmd, fork=fork, sig=signal.SIGTERM, sig_func=nginx_terminate)
    elif args.command == 'stop':
        call('%s -s stop' % cmd)
    elif args.command == 'restart':
        for cmd in ('stop', 'start'):
            args.command = cmd
            nginx(args)
    elif args.command == 'reload':
        call('%s -s reload' % cmd)
    else:
        raise ValueError("unknown command %s" % args.command)


def mongodb_firstboot(args):
    if os.path.exists(MONGODB_FIRSTBOOT_PATH):
        return
    ssl = ' --ssl' if args.ssl else ''
    call('mongo %s/admin %s %s' % (args.host, ssl, MONGODB_JS))
    with open(MONGODB_FIRSTBOOT_PATH, 'w') as f:
        f.write(NOW)


def mongodb_passwd(args):
    if not (args.user and args.password):
        raise ValueError("Invalid user: %s" % args.user)
    from metriqued.config import mongodb_config
    config = mongodb_config()
    ssl = ' --ssl' if config.ssl or args.ssl else ''
    old_pw = config.admin_password
    script = "db.changeUserPassword('%s', '%s')" % (args.user, args.password)
    call('mongo %s/admin %s --eval "%s" -u admin -p %s' % (args.host, ssl,
                                                           script, old_pw))


def mongodb_terminate(sig=None, frame=None):
    terminate(MONGODB_PIDFILE)
    sys.exit(2)


def mongodb(args):
    _fork = not args.nofork
    fork = '--fork' if _fork else ''

    if args.command == 'start':
        cmd = 'mongod -f %s %s' % (MONGODB_CONF, fork)
        cmd += ' --noprealloc --nojournal' if args.fast else ''
        call(cmd, fork=_fork, sig=signal.SIGTERM, sig_func=mongodb_terminate)
    elif args.command == 'stop':
        terminate(MONGODB_PIDFILE)
        args.command = 'clean'
        mongodb(args)
    elif args.command == 'restart':
        for cmd in ('stop', 'start'):
            args.command = cmd
            mongodb(args)
    elif args.command == 'clean':
        remove(MONGODB_LOCKFILE)
        remove(MONGODB_PIDFILE)
    elif args.command == 'trash':
        args.command = 'stop'
        mongodb(args)
        dest = pjoin(TRASH_DIR, 'mongodb-%s' % NOW)
        shutil.move(MONGODB_DIR, dest)
        makedirs(MONGODB_DIR)
        remove(MONGODB_FIRSTBOOT_PATH)
    elif args.command == 'firstboot':
        mongodb_firstboot(args)
    elif args.command == 'status':
        call('mongod %s --sysinfo' % args.host)
    elif args.command == 'keyfile':
        call('openssl rand -base64 741 -out %s' % MONGODB_KEYFILE)
        os.chmod(MONGODB_KEYFILE, 0600)
    elif args.command == 'passwd':
        mongodb_passwd(args)
    else:
        raise ValueError("unknown command %s" % args.command)


def _mongodb_is_locked(host, ssl, password):
    js_islocked = 'printjson(db.currentOp().fsyncLock)'
    locked = system(
        'mongo %s/admin %s --eval "%s" -u admin -p %s --quiet' % (
            host, ssl, js_islocked, password))
    return True if locked == 'true' else False


def _rsync_exec(args, show_stdout=True):
    ssh_user = args.ssh_user
    ssh_host = args.ssh_host
    saveas = re.sub('\W', '_', HOSTNAME)
    compress = '-z' if not args.nocompress else ''
    if not args.targets:
        raise OSError("one or more targets required!")
    targets = ' '.join(args.targets)
    if ssh_host:
        call('rsync -av %s -e ssh %s %s@%s:%s' % (compress, targets, ssh_user,
                                                  ssh_host, saveas),
             show_stdout=show_stdout)
    else:
        saveas = pjoin(BACKUP_DIR, saveas)
        call('rsync -av %s %s %s' % (compress, target, saveas),
             show_stdout=show_stdout)


def _mongodb_rsync(args):
    from metriqued.config import mongodb_config
    config = mongodb_config()
    ssl = ' --ssl' if config.ssl else ''
    password = config.admin_password
    host = args.mongodb_host

    args.targets.append(MONGODB_DIR)

    js_lock = 'db.fsyncLock()'
    js_unlock = 'db.fsyncUnlock()'

    # if mongodb is running, we'll need to sync and lock the db first
    running = get_pid(MONGODB_PIDFILE) != 0
    locked = _mongodb_is_locked(host, ssl, password) if running else False

    if running and not locked:  # sync and lock
        call('mongo %s/admin %s --eval "%s" -u admin -p %s' % (
            host, ssl, js_lock, password))

    try:
        _rsync_exec(args)
    finally:
        if running and _mongodb_is_locked(host, ssl, password):
            # unlock
            call('mongo %s/admin %s --eval "%s" -u admin -p %s' % (
                host, ssl, js_unlock, password))


def rsync(args):
    if args.mongodb_host:
        _mongodb_rsync(args)
    else:
        _rsync_exec(args)


def mongodb_backup(args):
    from metriqued.config import mongodb_config
    config = mongodb_config()

    prefix = 'mongodb'
    saveas = '__'.join((prefix, HOSTNAME, NOW))
    out = pjoin(BACKUP_DIR, saveas)

    host = config.host.split(',')[0]  # get the first host (expected primary)
    port = config.port
    p = config.admin_password
    password = '--password %s' % p if p else ''
    username = '--username %s' % config.admin_user if password else ''
    authdb = '--authenticationDatabase admin' if password else ''
    ssl = '--ssl' if config.ssl else ''

    cmd = ('mongodump', '--host %s' % host, '--port %s' % port,
           ssl, username, password, '--out %s' % out, authdb)
    cmd = ' '.join(cmd).replace('  ', ' ')
    call(cmd)

    saveas = out + '.tar.gz'
    backup(saveas, out)
    shutil.rmtree(out)

    backup_clean(args, BACKUP_DIR, 'mongodb')

    if args.scp_export:
        user = args.scp_user
        host = args.scp_host
        out_dir = args.scp_out_dir
        cmd = 'scp %s %s@%s:%s' % (saveas, user, host, out_dir)
        call(cmd)


def clean(args):
    # http://stackoverflow.com/a/785534/1289080
    os.system('find . -name "*.pyc" -exec rm -f {} \;')


def bump_version(regex, line, i, reset, **kwargs):
    # if we're bumping version, reset release to 1
    m = regex.match(line)
    if not m:
        raise ValueError(
            'Expected line matching __version__, got: %s' % line)
    current = m.groups()[0]
    current_parts = map(int, current.split('.'))
    if reset:
        current_parts[i] = 0
    else:
        current_parts[i] += 1
    bumped = '.'.join(map(str, current_parts))
    logger.info(' ... BUMP (VERSION) - %s->%s' % (current, bumped))
    return "__version__ = '%s'\n" % bumped


def bump_version_x(line, reset=False, **kwargs):
    return bump_version(RE_VERSION_X, line, 0, reset, **kwargs)


def bump_version_y(line, reset=False, **kwargs):
    return bump_version(RE_VERSION_Y, line, 1, reset, **kwargs)


def bump_version_z(line, reset=False, **kwargs):
    return bump_version(RE_VERSION_Z, line, 2, reset, **kwargs)


def bump_release(line, reset=False, ga=False):
    m = RE_RELEASE.match(line)
    if not m:
        raise ValueError(
            'Expected line matching __release__, got: %s' % line)
    current = int(m.groups()[1])
    if reset:
        bumped = 1
    else:
        bumped = current + 1  # bump by one

    if not ga:
        bumped = '"%sa"' % bumped
    else:
        # drop any 'a' if there is one
        bumped = re.sub('a$', '', str(bumped))

    logger.info(' ... BUMP (RELEASE): %s->%s' % (current, bumped))
    return '__release__ = %s\n' % bumped


def get_packages(args):
    global __pkgs__
    return [pjoin(SRC_DIR, pkg) for pkg in __pkgs__]


def update_line(args, regex, bump_func):
    pkg_paths = get_packages(args)
    for path in pkg_paths:
        logger.info(path)
        path = '%s/setup.py' % path
        with open(path) as setup_py:
            content = setup_py.readlines()
            for i, line in enumerate(content):
                if regex.match(line):
                    content[i] = bump_func(line)
                else:
                    continue
                break  # stop after the first replace...
        if not content:
            raise ValueError(
                "content was empty; didn't want to overwrite...")
        elif None in content:
            raise RuntimeError(
                "check your nrv strings; "
                " they're missing our regex: \n%s" % regex.pattern)
        content_str = ''.join(content)
        # write out the new setup file with bumped
        with open(path, 'w') as setup_py:
            setup_py.write(content_str)


def setup(args, cmd, pip=False):
    global __pkgs__
    if isinstance(cmd, basestring):
        cmd = cmd.strip()
    else:
        cmd = ' '.join([s.strip() for s in cmd])
    for path in __pkgs__:
        abspath = pjoin(SRC_DIR, path)
        os.chdir(abspath)
        if pip and args.slow:
            logger.info(system('pip %s -e %s' % (cmd, abspath)))
        elif pip:
            logger.info(system('pip-accel %s -e %s' % (cmd, abspath)))
        else:
            os.chdir(abspath)
            logger.info(system('python setup.py %s' % cmd))


def deploy(args):
    '''
    Order of Operations
    (NOT IN VIRTENV)
    + clone repo/pull branch
    + bump r
    + sdist upload
    (IN VIRTENV)
    + install dep
    + install metrique and friends
    '''
    virtenv = getattr(args, 'virtenv')
    if not virtenv:
        raise RuntimeError("virtenv required!")

    # we can't be in a virtenv when running the virtualenv.main() script
    deactivate(virtenv)

    # scratch the existing virtenv directory, if requested
    if args.trash:
        remove(virtenv)
        logger.info(system('%s/metrique mongodb trash' % GIT_DIR))

    # virtualenv.main; pass in only the virtenv path
    sys.argv = sys.argv[0:1] + [virtenv]
    # run the virtualenv script to install the virtenv
    virtualenv.main()

    # activate the newly installed virtenv
    activate(args)

    # make sure we have some basic defaults configured in the environment
    sys_firstboot(args)

    # make sure we have the installer basics and their up2date
    # pip-accel caches compiled binaries
    call('pip install -U pip setuptools')

    # install pip-accel and use it instead of pip unless slow install
    if args.slow:
        pip = 'pip'
    else:
        call('pip install pip-accel')
        pip = 'pip-accel'

    # this required dep is installed separately b/c virtenv
    # path resolution issues; fails due to being unable to find
    # the python headers in the virtenv for some reason.
    call('%s install -U cython numpy pandas' % pip)

    # optional dependencies; highly recommended! but slow to
    # install if we're not testing
    if args.ipython:
        call('%s install -U ipython' % pip)
    if args.test or args.pytest:
        call('%s install -U pytest' % pip)
    if args.docs:
        call('%s install -U sphinx' % pip)
        # pip-accel fails to install this package...
        call('pip install -U sphinx_bootstrap_theme')
    if args.supervisord:
        call('%s install -U supervisor' % pip)

    cmd = 'install'
    no_pre = getattr(args, 'no_pre', False)
    if not no_pre:
        cmd += ' --pre'
    setup(args, cmd, pip=True)

    if args.develop:
        path = pjoin(virtenv, 'lib/python2.7/site-packages/metrique*')
        mods = glob.glob(path)
        remove(mods)
        develop(args)

    # run py.test after install
    if args.test:
        for pkg in __pkgs__:
            call('py.test tests/%s' % pkg, cwd=GIT_DIR)


def bump(args, kind=None, reset=None):
    kind = kind or getattr(args, 'bump_kind', None) or 'r'
    reset = reset or getattr(args, 'reset', None)
    ga = getattr(args, 'ga', None)
    global __bumps__
    assert kind in __bumps__
    if kind == 'x':
        regex = RE_VERSION_X
        bump(args=args, kind='y', reset=True)
        bump_func = partial(bump_version_x, reset=reset)
    elif kind == 'y':
        regex = RE_VERSION_Y
        bump(args=args, kind='z', reset=True)
        bump_func = partial(bump_version_y, reset=reset)
    elif kind == 'z':
        regex = RE_VERSION_Z
        bump(args=args, kind='r', reset=True)
        bump_func = partial(bump_version_z, reset=reset)
    elif kind == 'r':
        regex = RE_RELEASE
        bump_func = partial(bump_release, reset=reset, ga=ga)
    update_line(args, regex, bump_func)


def build(args):
    cmd = 'build'
    setup(args, cmd)


def sdist(args, upload=None, bump_r=None):
    upload = upload or args.upload
    bump_r = bump_r or args.bump_r
    cmd = 'sdist'
    if upload:
        if bump_r:
            bump(args)
        cmd += ' upload'
    setup(args, cmd)


def develop(args):
    cmd = 'develop'
    setup(args, cmd)


def register(args):
    cmd = 'register'
    setup(args, cmd)


def status(path):
    pkg = os.path.basename(os.path.dirname(path))
    call('pip show %s' % pkg)


def ssl(args=None):
    logger.info("Generating self-signed SSL certificate + key + combined pem")
    call('openssl req -new -x509 -days 365 -nodes '
         '-out %s -keyout %s -batch' % (SSL_CERT, SSL_KEY))
    with open(SSL_PEM, 'w') as pem:
        with open(SSL_CERT) as cert:
            pem.write(''.join(cert.readlines()))
        with open(SSL_KEY) as key:
            pem.write(''.join(key.readlines()))


def rpms(args):
    if not os.path.exists(RPM_SYSTEM_RELEASE):
        raise OSError(
            "Non-RPM based host? Can't find %s" % RPM_SYSTEM_RELEASE)
    if USER != 'root':
        raise OSError("Must run this command as root, not %s" % USER)
    cmd = 'yum install -y %s' % ' '.join(RPMS)
    call(cmd, show_stdout=True)


def default_conf(path, template):
    if os.path.exists(path):
        path = '.'.join([path, 'default'])
    with open(path, 'w') as f:
        f.write(template)
    logger.info("Installed %s ..." % path)


def sys_firstboot(args=None):
    DEFAULT_METRIQUE_JSON = '''
    {
        "auto_login": false,
        "batch_size": 5000,
        "cube_autoregister": false,
        "debug": true,
        "host": "127.0.0.1",
        "log2file": true,
        "logstdout": false,
        "max_workers": %s,
        "password": "%s",
        "port": 5420,
        "sql_batch_size": 1000,
        "ssl": false,
        "ssl_verify": false
    }
    ''' % (multiprocessing.cpu_count(), PASSWORD)
    DEFAULT_METRIQUE_JSON = DEFAULT_METRIQUE_JSON.strip()

    DEFAULT_METRIQUED_JSON = '''
    {
        "api_docs": "%s",
        "cookie_secret": "%s",
        "debug": true,
        "host": "127.0.0.1",
        "host_LOCAL": "%s",
        "krb_auth": false,
        "log2file": true,
        "logstdout": false,
        "log_requests": false,
        "port": 5420,
        "realm": "metrique",
        "ssl": false,
        "ssl_certificate": "%s",
        "ssl_certificate_key": "%s",
        "superusers": ["admin", "%s"]
    }
    ''' % (API_DOCS_PATH, COOKIE_SECRET, LOCAL_IP,
        SSL_CERT, SSL_KEY, USER)
    DEFAULT_METRIQUED_JSON = DEFAULT_METRIQUED_JSON.strip()

    DEFAULT_MONGODB_JSON = '''
    {
        "auth": false,
        "root_password": "%s",
        "admin_password": "%s",
        "data_password": "%s",
        "host": "127.0.0.1",
        "journal": true,
        "port": 27017,
        "ssl": false,
        "ssl_certificate": "%s",
        "write_concern": 1
    }
    ''' % (PASSWORD, PASSWORD, PASSWORD, SSL_PEM)
    DEFAULT_MONGODB_JSON = DEFAULT_MONGODB_JSON.strip()

    DEFAULT_MONGODB_CONF = '''
    fork = true
    nohttpinterface = true
    dbpath = %s
    logpath = %s
    pidfilepath = %s

    #auth = true
    noauth = true

    bind_ip = 127.0.0.1
    #bind_ip = %s

    #sslOnNormalPorts = true
    #sslPEMKeyFile = %s

    #replSet = rs0
    #keyFile = %s
    ''' % (MONGODB_DIR, MONGODB_LOG, MONGODB_PIDFILE, LOCAL_IP,
        SSL_PEM, MONGODB_KEYFILE)
    DEFAULT_MONGODB_CONF = DEFAULT_MONGODB_CONF.strip()

    DEFAULT_MONGODB_JS = '''
    db = db.getSiblingDB('admin')
    db.addUser({'user': 'root', 'pwd': '%s', 'roles': ['dbAdminAnyDatabase',
            'userAdminAnyDatabase', 'clusterAdmin', 'readWriteAnyDatabase']});
    db.addUser({'user': 'admin', 'pwd': '%s', 'roles': ['dbAdminAnyDatabase',
            'userAdminAnyDatabase', 'readWriteAnyDatabase']});
    db.addUser({'user': 'metrique', 'pwd': '%s', 'roles': ['readAnyDatabase']});
    ''' % (PASSWORD, PASSWORD, PASSWORD)
    DEFAULT_MONGODB_JS = DEFAULT_MONGODB_JS.strip()

    DEFAULT_CELERY_JSON = '''
    {
        "BROKER_URL": "mongodb://admin:%s@127.0.0.1:27017",
        "BROKER_URL_LOCAL": "mongodb://admin:%s@%s:27017",
        "BROKER_USE_SSL": false
    }
    ''' % (PASSWORD, PASSWORD, LOCAL_IP)
    DEFAULT_CELERY_JSON = DEFAULT_CELERY_JSON.strip()

    DEFAULT_NGINX_CONF = '''
    worker_processes auto;
    daemon on;  # turn off to avoid forking on startup (supervisord)
    # see warnings: http://wiki.nginx.org/CoreModule#daemon
    user %s
    error_log %s;
    pid %s;
    events {
        worker_connections 1024;
        use epoll;
    }
    http {
        charset utf-8;
        client_max_body_size 0;  # disabled
        client_body_temp_path  %s 1 2;
        client_header_buffer_size 256k;
        large_client_header_buffers 8 1024k;

        proxy_temp_path   %s  1 2;
        proxy_cache_path  %s  levels=1:2     keys_zone=proxy_one:10m;

        fastcgi_temp_path   %s  1 2;
        fastcgi_cache_path  %s  levels=1:2   keys_zone=fastcgi_one:10m;

        uwsgi_temp_path   %s  1 2;
        uwsgi_cache_path  %s  levels=1:2     keys_zone=uwsgi_one:10m;

        scgi_temp_path   %s  1 2;
        scgi_cache_path  %s  levels=1:2     keys_zone=scgi_one:10m;

        # Enumerate all the Tornado servers here
        upstream frontends {
            server 127.0.0.1:5421;
            server 127.0.0.1:5422;
            server 127.0.0.1:5423;
            server 127.0.0.1:5424;
            #server %s:5421;
            #server %s:5422;
            #server %s:5423;
            #server %s:5424;
        }

        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        error_log %s;
        access_log %s;

        # Timeouts
        keepalive_timeout 3m;
        client_header_timeout  3m;
        client_body_timeout  3m;
        proxy_connect_timeout 3m;
        proxy_send_timeout 3m;
        proxy_read_timeout 3m;

        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        gzip on;
        gzip_min_length 1000;
        gzip_proxied any;
        gzip_types text/plain text/css text/xml
                application/x-javascript application/xml
                application/atom+xml text/javascript
                application/json;

        # Only retry if there was a communication error, not a timeout
        # on the Tornado server (to avoid propagating "queries of death"
        # to all frontends)
        proxy_next_upstream error;

        server {
            listen %s:5420;
            ssl                 off;
            ssl_certificate     %s;
            ssl_certificate_key %s;

            ssl_protocols        SSLv3 TLSv1 TLSv1.1 TLSv1.2;
            ssl_ciphers RC4:HIGH:!aNULL:!MD5;
            ssl_prefer_server_ciphers on;
            ssl_session_cache    shared:SSL:10m;
            ssl_session_timeout  60m;

            location ^~ /static/ {
                root %s;
                if ($query_string) {
                    expires max;
                }
            }

            location / {
                proxy_pass_header Server;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Scheme $scheme;
                proxy_pass http://frontends;

                proxy_set_header        Accept-Encoding   "";
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;

                ### Most PHP, Python, Rails, Java App can use this header ###
                #proxy_set_header X-Forwarded-Proto https;##
                #This is better##
                proxy_set_header        X-Forwarded-Proto $scheme;
                add_header              Front-End-Https   on;

                ### force timeouts if one of backend is died ##
                proxy_next_upstream error timeout invalid_header http_500 http_502
                                                                http_503 http_504;
            }
        }
    }
    ''' % (USER, NGINX_ERROR_LOG, NGINX_PIDFILE, TEMP_DIR,
        TEMP_DIR, CACHE_DIR, TEMP_DIR, CACHE_DIR, TEMP_DIR, CACHE_DIR,
        TEMP_DIR, CACHE_DIR, LOCAL_IP, LOCAL_IP, LOCAL_IP, LOCAL_IP,
        NGINX_ERROR_LOG, NGINX_ACCESS_LOG, LOCAL_IP, SSL_CERT, SSL_KEY,
        STATIC_PATH)
    DEFAULT_NGINX_CONF = DEFAULT_NGINX_CONF.strip()

    ENVIRONMENT = 'VIRTUAL_ENV="%s", HOME="%s", METRIQUE_GIT="%s"' % (
        VIRTUAL_ENV, HOME_DIR, GIT_DIR)
    DEFAULT_SUPERVISORD_CONF = '''
    [inet_http_server]
    port=127.0.0.1:9001
    ;port=%s:9001
    username=admin
    password=%s

    [rpcinterface:supervisor]
    supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

    [supervisord]
    logfile=%s
    pidfile=%s
    childlogdir=%s
    user=%s
    directory=%s
    environment=%s
    loglevel=debug

    [supervisorctl]
    serverurl=http://127.0.0.1:9001
    ;serverurl=http://%s:9001
    username=admin
    password=%s
    history_file=%s

    [program:mongodb]
    command=python metrique mongodb start --nofork
    process_name=mongodb
    numprocs=1
    priority=10
    startsecs=60
    stopwaitsecs=60

    [program:metriqued]
    command=python metrique metriqued start -P542%%(process_num)d --nofork
    process_name=metriqued-%%(process_num)d
    numprocs=4
    numprocs_start=1
    priority=20
    startsecs=60
    startretries=5

    [program:nginx]
    command=python metrique nginx start --nofork
    process_name=nginx
    numprocs=1
    priority=30
    startsecs=30

    [program:celeryd]
    command=python metrique celeryd start --nofork
    process_name=celeryd
    numprocs=1
    priority=40
    startsecs=30
    autorestart=true

    [program:celerybeat]
    command=python metrique celerybeat start --nofork
    process_name=celerybeat
    numprocs=1
    priority=41
    startsecs=30
    autorestart=true

    [program:viztriqued]
    command=python viztriqued start --nofork
    directory=path/to/viztrique/git/repo
    process_name=viztriqued
    numprocs=1
    priority=100
    ''' % (LOCAL_IP, PASSWORD, SUPERVISORD_LOGFILE, SUPERVISORD_PIDFILE,
        LOG_DIR, USER, GIT_DIR, ENVIRONMENT,
        LOCAL_IP, PASSWORD, SUPERVISORD_HISTORYFILE)
    DEFAULT_SUPERVISORD_CONF = DEFAULT_SUPERVISORD_CONF.strip()


    if os.path.exists(SYS_FIRSTBOOT_PATH):
        # skip if we have already run this before
        return

    # create default dirs in advance
    [makedirs(p) for p in (USER_DIR, PIP_CACHE_DIR, PIP_ACCEL_DIR,
                           PIP_EGGS, TRASH_DIR, LOG_DIR,
                           ETC_DIR, BACKUP_DIR, MONGODB_DIR,
                           CELERY_DIR, TEMP_DIR, CACHE_DIR,
                           GNUPG_DIR, PID_DIR)]

    # make sure the the default user python eggs dir is secure
    os.chmod(PIP_EGGS, 0700)

    # generate self-signed ssl certs
    ssl()

    # install default configuration files
    default_conf(METRIQUE_JSON, DEFAULT_METRIQUE_JSON)
    default_conf(METRIQUED_JSON, DEFAULT_METRIQUED_JSON)
    default_conf(MONGODB_JSON, DEFAULT_MONGODB_JSON)
    default_conf(MONGODB_CONF, DEFAULT_MONGODB_CONF)
    default_conf(MONGODB_JS, DEFAULT_MONGODB_JS)
    default_conf(CELERY_JSON, DEFAULT_CELERY_JSON)
    default_conf(NGINX_CONF, DEFAULT_NGINX_CONF)
    default_conf(SUPERVISORD_CONF, DEFAULT_SUPERVISORD_CONF)

    with open(SYS_FIRSTBOOT_PATH, 'w') as f:
        f.write(NOW)


def main():
    import argparse

    cli = argparse.ArgumentParser(description='Metrique Manage CLI')
    cli.add_argument('-V', '--virtenv')

    _sub = cli.add_subparsers(description='action', dest='action')

    # Automated metrique deployment
    _deploy = _sub.add_parser('deploy')
    _deploy.add_argument(
        '--slow', action='store_true', help="don't use pip-accel")
    _deploy.add_argument(
        '--no-pre', action='store_true',
        help='ignore pre-release versions')
    _deploy.add_argument(
        '--develop', action='store_true', help='install in "develop mode"')
    _deploy.add_argument(
        '--test', action='store_true', help='run tests after deployment')
    _deploy.add_argument(
        '--ipython', action='store_true', help='install ipython')
    _deploy.add_argument(
        '--pytest', action='store_true', help='install pytest')
    _deploy.add_argument(
        '--docs', action='store_true', help='install doc utils')
    _deploy.add_argument(
        '--supervisord', action='store_true', help='install doc utils')
    _deploy.add_argument(
        '--trash', action='store_true', help='fresh install (rm old virtenv)')
    _deploy.set_defaults(func=deploy)

    # PIP standard build
    _build = _sub.add_parser('build')
    _build.set_defaults(func=build)

    # PIP sdist build
    _sdist = _sub.add_parser('sdist')
    _sdist.add_argument('-u', '--upload', action='store_true')
    _sdist.add_argument('-b', '--bump-r', action='store_true')
    _sdist.set_defaults(func=sdist)

    # PIP `develop` deployment
    _develop = _sub.add_parser('develop')
    _develop.set_defaults(func=develop)

    # PIP pkg register
    _register = _sub.add_parser('register')
    _register.set_defaults(func=register)

    # Bump metrique setup.py version/release
    _bump = _sub.add_parser('bump')
    _bump.add_argument('-k', '--bump-kind', choices=__bumps__)
    _bump.add_argument('-r', '--reset', choices=__bumps__)
    _bump.add_argument('-ga', action='store_true', dest='ga')
    _bump.set_defaults(func=bump)

    # PIP status
    _status = _sub.add_parser('status')
    _status.set_defaults(func=status)

    # Clean-up routines
    _clean = _sub.add_parser('clean')
    _clean.set_defaults(func=clean)

    # MongoDB Server
    _mongodb = _sub.add_parser('mongodb')
    _mongodb.add_argument('command',
                          choices=['start', 'stop', 'restart',
                                   'clean', 'trash', 'status',
                                   'keyfile', 'firstboot', 'passwd'])
    _mongodb.add_argument('-H', '--host', default='127.0.0.1')
    _mongodb.add_argument('-f', '--fast', action='store_true')
    _mongodb.add_argument('-s', '--ssl', action='store_true')
    _mongodb.add_argument('-u', '--user')
    _mongodb.add_argument('-p', '--password')
    _mongodb.add_argument('-F', '--nofork', action='store_true')
    _mongodb.set_defaults(func=mongodb)

    # rsync
    _rsync = _sub.add_parser('rsync')
    _rsync.add_argument('targets', type=list, nargs='*')
    _rsync.add_argument('-m', '--mongodb-host')
    _rsync.add_argument('-Z', '--nocompress', action='store_true')
    _rsync.add_argument('-H', '--ssh-host')
    _rsync.add_argument('-u', '--ssh-user', default='backup')
    _rsync.set_defaults(func=rsync)

    # MongoDB Backup
    _mongodb_backup = _sub.add_parser('mongodb_backup')
    _mongodb_backup.add_argument('-c', '--config-file')
    _mongodb_backup.add_argument('-k', '--keep', type=int, default=3)
    _mongodb_backup.add_argument('-x', '--scp-export', action='store_true')
    _mongodb_backup.add_argument('-H', '--scp-host')
    _mongodb_backup.add_argument('-u', '--scp-user', default='backup')
    _mongodb_backup.add_argument('-O', '--scp-out-dir')
    _mongodb_backup.set_defaults(func=mongodb_backup)

    # nginx Server
    _nginx = _sub.add_parser('nginx')
    _nginx.add_argument('command',
                        choices=['start', 'stop', 'reload',
                                 'restart', 'test'])
    _nginx.add_argument('-m', '--metriqued-config-file',
                        default=METRIQUED_JSON)
    _nginx.add_argument('-F', '--nofork', action='store_true')
    _nginx.set_defaults(func=nginx)

    # metriqued Server
    _metriqued = _sub.add_parser('metriqued')
    _metriqued.add_argument('command', choices=['start', 'stop', 'status',
                                                'firstboot'])
    _metriqued.add_argument('-c', '--server-config-file',
                            default=METRIQUED_JSON)
    _metriqued.add_argument('-P', '--port', type=int, default=5420)
    _metriqued.add_argument('-i', '--instances', type=int)
    _metriqued.add_argument('-s', '--signal', type=int)
    _metriqued.add_argument('-F', '--nofork', action='store_true')
    _metriqued.set_defaults(func=metriqued)

    # metriqued Backup
    _metriqued_backup = _sub.add_parser('metriqued_backup')
    _metriqued_backup.add_argument('-k', '--keep', type=int, default=3)
    _metriqued_backup.add_argument('-x', '--scp-export', action='store_true')
    _metriqued_backup.add_argument('-H', '--scp-host')
    _metriqued_backup.add_argument('-u', '--scp-user', default='backup')
    _metriqued_backup.add_argument('-O', '--scp-out-dir')
    _metriqued_backup.set_defaults(func=metriqued_backup)

    # celeryd task run
    _celeryd_task = _sub.add_parser('celeryd_task')
    _celeryd_task.add_argument('task')
    _celeryd_task.add_argument('--tasks-mod', default='dataservices.tasks')
    _celeryd_task.set_defaults(func=celeryd_task)

    # celeryd server
    _celeryd = _sub.add_parser('celeryd')
    _celeryd.add_argument('command', choices=['start', 'stop', 'clean'])
    _celeryd.add_argument('--tasks-mod', default='dataservices.tasks')
    _celeryd.add_argument('-F', '--nofork', action='store_true')
    _celeryd.set_defaults(func=celeryd)

    # celerybeat server
    _celerybeat = _sub.add_parser('celerybeat')
    _celerybeat.add_argument('command', choices=['start', 'stop', 'clean'])
    _celerybeat.add_argument('--tasks-mod', default='dataservices.tasks')
    _celerybeat.add_argument('-F', '--nofork', action='store_true')
    _celerybeat.set_defaults(func=celerybeat)

    # supervisord server
    _supervisord = _sub.add_parser('supervisord')
    _supervisord.add_argument('command', choices=['start', 'stop', 'clean'])
    _supervisord.set_defaults(func=supervisord)

    # SSL creation
    _ssl = _sub.add_parser('ssl')
    _ssl.set_defaults(func=ssl)

    # RPM Dependency Install
    _rpms = _sub.add_parser('rpms')
    _rpms.set_defaults(func=rpms)

    # parse argv
    args = cli.parse_args()

    if args.action != 'deploy':
        # Activate the virtual environment in this python session if
        # parent env has one set
        activated = activate(args)
        if not bool(activated):
            raise RuntimeError("No virtual environment detected!")

    # run command
    args.func(args)


if __name__ == '__main__':
    main()
